buildscript {
    ext {
        springBootVersion = '3.4.5'
        graalvmBuildToolVersion = '0.10.3'
        springDependencyManagementVersion = '1.1.7'
        awsSdkVersion = '2.25.1'
        dynamodbVersion = '2.31.30'
        mapstructVersion = '1.6.3'
        jerseyVersion = '3.1.10'
        reactorNettyVersion = '1.3.0-M2'
        checkstyleVersion = '10.12.4'
        jacocoVersion = '0.8.13'
        mockitoVersion = '5.2.0'
        springDocVersion = '2.8.6'
        jakartaWsVersion = '3.1.0'
        finalJarName = 'spring-run.jar'
    }
}

plugins {
    id 'java'
    id 'org.springframework.boot' version "${springBootVersion}"
    id 'org.graalvm.buildtools.native' version "${graalvmBuildToolVersion}"
    id 'io.spring.dependency-management' version "${springDependencyManagementVersion}"
    id 'checkstyle'
    id 'jacoco'
}

group = 'com.santander.springcepapi'
version = '0.0.1'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(22)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Spring Boot
    implementation "org.springframework.boot:spring-boot-starter-web"
    implementation "org.springframework.boot:spring-boot-starter-validation"
    implementation "org.springframework.boot:spring-boot-docker-compose"

    // Web-flux
    implementation 'org.springframework:spring-webflux'

    // AWS & DynamoDB
    implementation platform("software.amazon.awssdk:bom:${awsSdkVersion}")
    implementation "software.amazon.awssdk:dynamodb:${dynamodbVersion}"
    implementation "software.amazon.awssdk:dynamodb-enhanced:${dynamodbVersion}"

    // Jakarta & Jersey
    implementation "jakarta.ws.rs:jakarta.ws.rs-api:${jakartaWsVersion}"
    implementation "org.glassfish.jersey.core:jersey-common:${jerseyVersion}"

    // Documentação & Utilitários
    implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:${springDocVersion}"
    implementation "io.projectreactor.netty:reactor-netty:${reactorNettyVersion}"

    // MapStruct
    implementation "org.mapstruct:mapstruct:${mapstructVersion}"
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"

    // Testes
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'software.amazon.awssdk:apache-client'
    testImplementation "org.mockito:mockito-inline:${mockitoVersion}"

    // Checkstyle
    checkstyle "com.puppycrawl.tools:checkstyle:${checkstyleVersion}"
}

bootBuildImage {
    imageName = "contecin/${project.name}"
    tags = ["latest", version]
    builder = "paketobuildpacks/builder-jammy-base:latest"
    environment = [
            "BP_JVM_VERSION": "22"
    ]
}

// Configuração do Checkstyle
checkstyle {
    toolVersion = checkstyleVersion
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
}

configurations {
    nativeTest
}

// Configuração de Testes
test {
    useJUnitPlatform()

    systemProperty 'spring.profiles.active', 'test'
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
    }
    maxHeapSize = '1G'
    jvmArgs "-javaagent:${configurations.testRuntimeClasspath.find { it.name.contains('mockito-core') }}", '-Xshare:off'
}

// Configuração do Jacoco
jacoco {
    toolVersion = jacocoVersion
}

def excludedFiles = []

tasks.register('coverage') {
    group = 'qualidade'
    description = 'Executa o test e cobertura do código'
    dependsOn 'jacocoTestReport'
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        csv.required = false
        html.required = true
        html.outputLocation = layout.buildDirectory.dir('jacocoHtml')
    }

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: excludedFiles)
        }))
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }
            excludes = []
        }
        rule {
            element = 'METHOD'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }
        }
    }

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: excludedFiles)
        }))
    }
}

// Configurações de Compilação
tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += ["-Xlint:unchecked"]
}

// Tarefa de Verificação de Cobertura
tasks.register('checkCoverage') {
    dependsOn test
    dependsOn jacocoTestReport
    dependsOn jacocoTestCoverageVerification
}

// Configuração do Jar
bootJar {
    archiveFileName = finalJarName
}